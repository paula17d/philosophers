STRUCTURE
* = current
Day	Goals
1	$âœ… Read the subject thoroughly. Understand the rules and constraints.
2	$âœ… Research: Read about the Dining Philosophers problem, threads, and mutexes.
3	$âœ… Implement basic structure: parse arguments, initialize data, create structs.
4	$âœ… Add thread creation for philosophers. They should loop through actions.
	     -> check create_threads_in_loops
5	*âœ… Implement forks using mutexes. Test concurrent access logic. (first do eat, sleep, think. then forks)
6	âœ… Handle timing and philosopher death conditions. Implement monitoring thread.
7	âœ… Add logging (optional but helpful). Handle cleanup of threads and mutexes.
8	âœ… Test edge cases: one philosopher, max philosophers, starvation conditions.
9	âœ… Refactor code, follow Norminette, and test memory leaks with Valgrind.




STRUCTURE
1. implement one philo's logic in the routine and test it with one thread
2. THEN: scale it to multiple threads (while loop philo[i])
- every philo runs the same loop (think, take forks, eat, sleep, repeat: ROUTINE ft)
- how does each one know when to do what?
--> code is same for everyone but each thread execute it at its own pace (depneds on time thread started,
CPU time, whether forks are free, sleeping)
--> so u naturaly get this behavior of philo 1 thinking, philo 2 eating, philo 3 sleeping
- handled by: pthread_create(), usleep() or custom_sleep() for pacing, pthread_mutex_lock() for fork control
- example: 
philo1: thinking â†’ forks are free â†’ eating â†’ sleeping â†’ thinking
philo2: thinking â†’ tries to take forks â†’ can't â†’ waits â†’ eats â†’ sleeps

- lEARN AOUT TIMING ASPECT

STRUCTS
- a personal philo struct w all data needed for them (left, right fork,...) (that also includes the main struct)
- a main struct (this is shared data -> time_to_die, time_to_eat)

MUTEXES
- since forks are shared resources, mutexes prevent two philos from picking up the same fork at same time
--> do this when creating a thread, as input function is the routine (which includes one part w fork picking up -> this is where i do mutex loc around?? bc sleeping & thinking everyone can do)
- each fork is represented by a unique mutex pthread_mutex_t forks [N]
	--> each philo is locking a different mutex depending on ID & left/right fork index
- MUTEX DEFINITION: only one thread can access a shared resource at a time (prevents data races or multiple threads messing w the same thing simultanosley). so others wait until the mutex (that contains the fork) is released

QUESTIONS
- usleep or whatever. how does a philo know when to wake up ex? based on timing logic
--> ends when time_to_sleep (entered arg) is done. same w eating.
--> USE CUSTOM_SLEEP 9not usleep bc it iwll sleep no matter what, but need to check DURING if the philo 
	has died. custom_sleep sleeps in small chucks  (500-1000 ms) and checks after each chunk if time_to_die has been reached, then stops and prints dying. still usleep but put in the ft custom_sleep which includes check_if_philo_died
	-> still small delay even when divided into small chunks, but thats okay (as long as printed after correct timing)
	-> OR can do a MONITOR THREAD: regularly checks all philos last_meal_time  (monitors routine,  overseer of simulation -> doing entire routine, the monitor (implemented in main) watches all philos and checks if anyone starved yet / died)
		-monitor: seperate thread that loops in background, checking all philo's last_meal_time every few ms 
		- prints death message, and includes death_flag in main struct, and exits simulation/program(?)
		-PROS: philos dont have to check themselves if theyre dead. prevents death being printed late
- need to print time stamps (first) and philo IDs (second) in line and then what each is doing

DEATH
--> PART MISSING STILL: needs to check whether it needs to die 
-----> track if currenttime - last_meal_time is biggger than time_to_die, if not continue for next action
- need to check time from last meal to next meal. (the max time is passed from arg terminal.)


SEATING ARRANGEMENTS (QUESTION!!!!!!!!!)
Philosopher number 1 sits next to philosopher number number_of_philosophers.
Any other philosopher, numbered N, sits between philosopher N - 1 and philosopher
N + 1.
--> how do i do this? thru struct?
- philosophers are numbered N

-
[SUBJECT RULES]
PRINTING FORMAT
â—¦ timestamp_in_ms X has taken a fork
â—¦ timestamp_in_ms X is eating
â—¦ timestamp_in_ms X is sleeping
â—¦ timestamp_in_ms X is thinking
â—¦ timestamp_in_ms X died

A message announcing a philosopherâ€™s death must be displayed within 10 ms of
their actual death.

There is one fork between each pair of philosophers. Therefore, if there are several
philosophers, each philosopher has a fork on their left side and a fork on their right
side. If there is only one philosopher, they will have access to just one fork.
-

THREADS vs (fork wait)
- threads are in the same process (cooperative)
- forks create different processes (isolated)

- number of philosphers should be limited to around 200 (to prevent huge memory usage or crash, delays, weird race conditions)

REMEMBER!!!!!!!
structs dont have malloc, so just pass the struct around
- using a pointer (so its allocated on the stack, not on heap)
-  even if you're using the struct in other functions, you still donâ€™t need malloc as long as the struct is declared in main() (or a function that stays alive) and passed by pointer. stays alive until main end. editing & reading same block of memory

**********
FOR GIT
git add .
git reset TODO
***********


NEW KNOWLEDGE****
NOTE pointers reminder:
- declare the struct in main() 
- pass &data once from main() 
- always just pass data (already a pointer) to other functions 

NOTE: pthread function input.
- if i pass a function (routine) into where the thread is being created, 
the function can only contain (void *arg) as input (a pointer) 
--> therefore, i need to recast my original input within the routine ft.
- When a function is required to accept a void *arg, it means that the function is designed to be genericâ€”it can receive a pointer to any data type. '

make sure to read subject w allowed functions!(usleep etc.)



PHILO TESTER abdullah (slack group)


put in deathflag for while loop conditions



EX. 
number_of_philosophers: 10
time_to_die: 33
time_to_eat: 45
time_to_sleep: 21


1. implement routine
2. create timing functiont (that starts timing counter from beginning of routine!)



if uneven number of philos (5)
- one uneven/even philo will be able to only grab one fork
- means he will be waiting until other one is done BUT then immediately grab 
  another fork once the others ones are done. -> makes sure that he will def be eating

Each philosopher i has:
left_fork = i
right_fork = (i + 1) % N
ðŸ§  Example:
Philo 0 needs fork 0 and fork 1
Philo 1 needs fork 1 and fork 2
Philo 2 needs fork 2 and fork 3
...
Philo 4 needs fork 4 and fork 0
So you can imagine:
Philo 0 and Philo 2 could eat at the same time (no fork overlap).
But Philo 0 and Philo 1 cannot, because they both need fork 1.
